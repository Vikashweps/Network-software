# GraphQL — спроси только то, что нужно

В REST у вас есть жесткий набор эндпоинтов. Хочешь пользователя? `GET /users/1`. Хочешь его посты? `GET /users/1/posts`.
В GraphQL эндпоинт всего один — `/graphql`. Клиент шлёт туда запрос на специальном языке запросов:
```graphql
query {
  user(id: 1) {
    name
    posts {
      title
    }
  }
}
```
И получает ровно то, что просил. Ни байтом больше. Это перекладывает контроль над данными с сервера на клиента.

## Ключевые понятия
- **Schema** (Схема) — строго типизированный контракт. В ней описано, какие типы данных существуют и как они связаны.
- **Type** (Тип) — описание объекта (например, `User` с полями `id: ID!` и `name: String!`).
- **Query** — аналог GET в REST. Точка входа для чтения данных.
- **Mutation** — аналог POST/PUT/DELETE. Точка входа для изменения данных.
- **Resolver** (Резолвер) — функция кода, которая знает, *откуда* взять данные для конкретного поля (из базы, из API, из файла).

## Проблемы REST, которые решает GraphQL
1. **Overfetching**: Сервер отдал 50 полей, а клиенту нужно только одно. Тратим трафик зря.
2. **Underfetching**: Чтобы отрисовать профиль, клиенту нужно сделать 3 запроса: за юзером, за его друзьями и за последними фото. В GraphQL это один запрос.

## Инструменты
Для Python популярны библиотеки:
- **Strawberry** (современная, на аннотациях типов, рекомендуем).
- **Graphene** (классическая, похожа на Django models).
- **Ariadne** (schema-first подход).
